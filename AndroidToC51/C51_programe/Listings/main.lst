C51 COMPILER V9.56.0.0   MAIN                                                              06/02/2017 17:50:14 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main
                    -.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include "STC89C5X.h"
   2          #include "intrins.h"
   3          #include "panquanxing.h"
   4          sbit T_STR = P0^5;       //Ëø´æÒý½Å£¬ÆÁÉÏ±êÊ¶Î»STR
   5          sbit R1    = P0^4;       //Êý¾ÝÒý½Å£¬ÆÁÉÏ±êÊ¶R1
   6          sbit T_CLK = P0^6;       //Ê±ÖÓÒý½Å£¬ÆÁÉÏ±êÊ¶Î»CLK
   7          sbit OE    = P0^7;       //Ê¹ÄÜÒý½Å£¬ÆÁÉÏ±êÊ¶EN/OE
   8          unsigned char isEven;
   9          unsigned int startAddr=0;//ÓÃÀ´±£´æ³õÊ¼µØÖ·µÄ
  10          unsigned int inputCount=0;//±£´æÀ¶ÑÀÊäÈëµÄ×Ö·ûµÄ¸öÊý
  11          unsigned char wordCount=0;//±£´æÔÚeepromÖÐµÄ×Ö·ûµÄ¸öÊý
  12          
  13          unsigned char MoveBitNum,MoveBitNumtemp,IncNum;//ÒÆ¶¯Î»Êý,ÁÙÊ±ÒÆ¶¯Î»Êý£¬´óÓÚÒ»¸ö×Ö½ÚÔö¼Ó×Ö½ÚÊý
  14          unsigned char HzNum;//ºº×Ö¸öÊý
  15          unsigned char buff[10]={0};
  16          
  17          unsigned int offset1=0,offset2=0,offset3=0;
  18          unsigned int numCount1=0,numCount2=0;
  19          unsigned int wordCountBounder;
  20          
  21          void InitConfigure(void);
  22          void writeNewCheckCount();
  23          void InputByte(uchar);
  24          void receiveData();
  25          uchar myReadLastDataOnSector();
  26          void EEPROM_Init_Zero(uint);
  27          void myDelay(uchar);
  28          void main(void){
  29   1        uchar count;//16ÐÐÉ¨ÃèÊý¾Ý£¬·¶Î§0-15
  30   1        uint i,j;
  31   1        uchar temp;
  32   1      
  33   1        //ÉèÖÃÀ¶ÑÀ½ÓÊÕ²¨ÌØÂÊÎª9600Hz@22.1184MHz
  34   1        TMOD&=0x0f;
  35   1        TMOD|=0x20;//ÉèÖÃTMODÎª0x20
  36   1        TH1=0xfa;
  37   1        TL1=0xfa;
  38   1        SCON=0x70;
  39   1        ET1=0;//½ûÖ¹¶¨Ê±Æ÷1µÄÖÐ¶Ï
  40   1        TR1=1;//Æô¶¯¼ÆÊ±Æ÷Ò»¿ªÊ¼¼ÆÊ±
  41   1        
  42   1        wordCount=myReadLastDataOnSector();
  43   1        wordCount+=1;
  44   1        wordCount>>=1;
  45   1        P2=wordCount;
  46   1        while(1){
  47   2            i++;
  48   2          if(inputCount==1){
  49   3              inputCount=0;
  50   3          }
  51   2          receiveData();
  52   2          //if(i==20)//¸ü¸ÄÁ÷¶¯ËÙ¶È,1Tµ¥Æ¬»úºÍ12Tµ¥Æ¬»úËÙ¶È´óÔ¼5-8±¶£¬×¢Òâ¸ü¸Ä²ÎÊý
  53   2          if(i==60)
  54   2          {
C51 COMPILER V9.56.0.0   MAIN                                                              06/02/2017 17:50:14 PAGE 2   

  55   3            i=0;
  56   3            MoveBitNum++;
  57   3            if(MoveBitNum==16)//Ã¿´ÎÒÆ¶¯ÍêÒ»¸öºº×Ö´óÐ¡ºóÑ­»·
  58   3            {
  59   4                MoveBitNum=0;
  60   4                HzNum+=1;    //µ÷ÓÃÏÂÒ»¸öºº×Ö
  61   4                if(HzNum>=wordCount+4)//ÐèÒªÏÔÊ¾µÄºº×Ö¸öÊý£¬°üÀ¨Ç°ÃæµÄÒ»ÆÁ¿Õ×Ö·ûµÄ¸öÊý£¬ºóÃæÇåÆÁµÄ¿Õ×Ö·û²»°üº¬ÔÚÄÚ,Õâ
             -ÀïÊÇ(ºº×Ö¸öÊý+4)
  62   4                   HzNum=0;   //ÍêÈ«ÏÔÊ¾ÍêºóÑ­»·µ÷ÓÃ
  63   4            }
  64   3          }
  65   2      
  66   2          myDelay(1);//¿ØÖÆÉ¨ÃèÆµÂÊ
  67   2          
  68   2          offset1=HzNum;
  69   2          offset1<<=5;
  70   2          offset2=HzNum;
  71   2          offset2<<=1;
  72   2          offset2+=1;
  73   2          offset2<<=4;
  74   2          wordCountBounder=wordCount;
  75   2          wordCountBounder<<=5;
  76   2          wordCountBounder+=0x0080;
  77   2          
  78   2          for(j=0;j<5;j++) //È¡Ã¿¸öºº×ÖµÄÇ°2¸ö×Ö½Ú£¬4¸öºº×Ö×é³ÉÒ»ÐÐ£¬Êý¾Ý´«ÊäÍê³ÉºóËø´æÊä³ö¼´¿É£¬ÕâÀïÐèÒª¶àÈ¡³öÒ»¸
             -öºº×Ö×÷Îª»º³å
  79   2          {                //Ô­À´j=4£¬ÏÖÔÚj=5.
  80   3      
  81   3            offset3=j;
  82   3            offset3<<=5;
  83   3            numCount1=0+offset1+offset3+count;
  84   3            numCount2=0+offset2+offset3+count;
  85   3            if(numCount1<0x0080||numCount1>=wordCountBounder){
  86   4              buff[j+j]=0x00;
  87   4            }else{    
  88   4              buff[j+j]=EEPROM_ReadByte(0x2200+numCount1-0x0080);
  89   4            }
  90   3            
  91   3            if(numCount2<0x0080||numCount2>=wordCountBounder){
  92   4              buff[j+j+1]=0x00;
  93   4            }else{
  94   4              buff[j+j+1]=EEPROM_ReadByte(0x2200+numCount2-0x0080);
  95   4            }
  96   3          }
  97   2          if(MoveBitNum<8)                   //  ÅÐ¶ÁÒÆ¶¯¾àÀëÊÇ´óÓÚÒ»¸ö×Ö½Ú»¹ÊÇÐ¡ÓÚÒ»¸ö×Ö½Ú£¬ÒòÎªÒ»¸ö×Ö½Ú×óÒÆÓÒÒÆ×
             -î´óÖ»ÄÜ8Î»
  98   2          { 
  99   3            IncNum=0;
 100   3            MoveBitNumtemp=MoveBitNum; 
 101   3          }else{ 
 102   3            IncNum=1; 
 103   3            MoveBitNumtemp=MoveBitNum-8;//´óÓÚ8¾Í¼õÈ¥8µÃµ½µÄÊýÖµ»¹ÊÇÐ¡ÓÚ8
 104   3          }
 105   2          T_STR=0;       //Ëø´æÎÞÐ§
 106   2          for(j=0;j<8;j++)          //°´bitµÄ·½Ê½ÒÆ¶¯»º³åÇøµÄÄÚÈÝ£¬È»ºóÊä³öµ½595£¬¼´È¡³öµÄÊýÖµÃ¿¸ö×Ö½Ú×óÒÆÒ»¶¨µÄÎ»
             -Êý£¬
 107   2          {                                     //ºóÃæ×óÒÆ³öµÄÊý¾ÝÕûºÏµ½Ç°ÃæµÄ×Ö½ÚÖÐ£¬±£³ÖÊý¾ÝµÄÁ¬ÐøÐÔ       
 108   3            temp=(buff[j+IncNum]>>MoveBitNumtemp)|(buff[j+1+IncNum]<<(8-MoveBitNumtemp));//Õâ¾ä±È½ÏÖØÒª£¬ÐèÒª×ÔÐÐÄÃ
             -³ö2¸ö×Ö½ÚµÄÊý¾ÝÄ£Äâ·ÖÎö
 109   3            InputByte(temp);//Êä³öµ½595
 110   3          }//8¸ö×Ö½Ú´«ÊäÍêËø´æÊä³ö
 111   2          OE = 1;
C51 COMPILER V9.56.0.0   MAIN                                                              06/02/2017 17:50:14 PAGE 3   

 112   2          P0=15-count;//ÓÃP0¿ÚµÄÇ°4Î»¿ØÖÆ16ÐÐ£¬ÆÁÄÚ²¿Í¨¹ý4-16ÒëÂëÆ÷¹¤×÷£¬Ñ­»·É¨Ãè16ÐÐ
 113   2          T_STR=1;      //Ëø´æÓÐÐ§£¬´ËÊ±Ò»ÐÐµÄÊý¾ÝÏÔÊ¾µ½ÆÁÉÏ
 114   2          OE = 0;
 115   2          count++;
 116   2          if(count==16)
 117   2            count=0;
 118   2        }
 119   1      }
 120          
 121          //¿ÉÄÜÓÉÓÚ±¾ÈËµÄ¼¼ÊõÎÊÌâ£¬´Ëº¯ÊýÖ»ÄÜ¶¨ÒåÔÚ´Ë£¬¶¨Òåµ½ÁíÍâµÄÎÄ¼þ»áÎÞ·¨Ð´ÈëEEPROM
 122          void writeNewCheckCount(){  
 123   1        uint sectorOne=0x2000;
 124   1        while(sectorOne<=0x21ff&&EEPROM_ReadByte(sectorOne)!=0xff){
 125   2          ++sectorOne;
 126   2        }
 127   1          //ÕâÀï¿ÉÒÔÍ¨¹ý¶øÇÒsectorOne»áÃ¿´Î×ÔÔö1
 128   1        if(sectorOne>0x21ff){
 129   2          EEPROM_EraseSector(0x2000);
 130   2          EEPROM_WriteByte(0x2000,SBUF);//ÕâÀïÖ»ÄÜÓÃSBUF,»òÕßÊÇÖ¸Õë,ÒòÎª²ÎÊý±äÁ¿ÔÚ²»Í¬µÄcÎÄ¼þ£¬hÎÄ¼þ²»ÄÜ´«µÝÌ«¶à´Î
             -£¬ÈÝÒ×Ôì³ÉÎÞ·¨½ÓÊÕµ½±äÁ¿
 131   2        }else{
 132   2          EEPROM_WriteByte(sectorOne,SBUF);
 133   2        }
 134   1      }
 135          void InputByte(uchar DataR1) //Ð´Ò»¸ö×Ö½Ú
 136          { 
 137   1        uchar i;
 138   1        for(i=8; i>0; i--)
 139   1        {
 140   2          R1 = !(DataR1&0x01);                   
 141   2          T_CLK = 0;
 142   2          T_CLK = 1;
 143   2          DataR1 = DataR1 >> 1; 
 144   2        } 
 145   1      }
 146          
 147          uchar myReadLastDataOnSector(){//²»ÄÜÔÚÖÐ¶ÏÖÐÊ¹ÓÃ´Ëº¯Êý
 148   1        uchar checkCount;
 149   1        uint sectorOne=0x2000;
 150   1        while(sectorOne<=0x21ff&&EEPROM_ReadByte(sectorOne)!=0xff){
 151   2          ++sectorOne;
 152   2        }
 153   1        if(sectorOne>0x2000){
 154   2          checkCount=EEPROM_ReadByte(sectorOne-1);
 155   2        }else{
 156   2          checkCount=0;//null value for write!
 157   2        }
 158   1        return checkCount;
 159   1      }
 160          
 161          void receiveData(){
 162   1        if(RI&&inputCount==0){
 163   2          startAddr=0x2200;//Êý¾ÝµÄ
 164   2          writeNewCheckCount();//ÏÈ°Ñ¼ÆÊý±£´æÆðÀ´
 165   2          wordCount=SBUF;//×î¶à96¸ö×Ö·û£¬¼´¿ÉÒÔ×°ÔØ96¸öÓ¢ÎÄ×Ö·û£¬48¸öºº×Ö
 166   2          inputCount=wordCount;//Ã¿¸ö×Ö·û°üº¬16¸ö×Ö½ÚµÄ×ÖÄ£Êý¾Ý
 167   2          if(wordCount%2){
 168   3            isEven=1;
 169   3          }else{
 170   3            isEven=0;
 171   3          }
 172   2          inputCount<<=4;
C51 COMPILER V9.56.0.0   MAIN                                                              06/02/2017 17:50:14 PAGE 4   

 173   2          EEPROM_EraseSector(0x2200);//²Á³ýµÚÈýÉÈÇø
 174   2          EEPROM_EraseSector(0x2400);//²Á³ýµÚËÄÉÈÇø
 175   2          EEPROM_EraseSector(0x2600);//²Á³ýµÚÎåÉÈÇø
 176   2          //ÒòÎªwordCountÐèÒª¸³Öµ¸øinputCount,ËùÒÔÖ»ÄÜ×îºó×ªÎªHzk×Ö·ûÊý
 177   2          wordCount++;
 178   2          wordCount>>=1;//½«wordCount×ªÎª¶ÔÓÚµÄhzk×Ö·û¸öÊý
 179   2          while(inputCount){
 180   3            RI=0;
 181   3            inputCount-=1;
 182   3            while(RI==0);
 183   3            EEPROM_WriteByte(startAddr,SBUF);//Ð´Êý¾Ý£¬Ã¿Ð´Ò»¸ö×Ö½ÚµØÖ·×ÔÔö1
 184   3            startAddr+=1;
 185   3          }
 186   2        }
 187   1        if(isEven){
 188   2          EEPROM_Init_Zero(startAddr);
 189   2          isEven=0;
 190   2        }
 191   1        RI=0;
 192   1      }
 193          void EEPROM_Init_Zero(uint startAddr){
 194   1        uchar num=16;
 195   1        ISP_CONTR=0x81;
 196   1        ISP_CMD=0x02;
 197   1        while(num){
 198   2          num-=1;
 199   2          ISP_ADDRL=startAddr;
 200   2          ISP_ADDRH=startAddr>>8;
 201   2          ISP_DATA=0x00;
 202   2          ISP_TRIG();
 203   2          _nop_();
 204   2          startAddr+=1;
 205   2        }
 206   1        disableEEPROM();
 207   1      }
 208          void myDelay(uchar t)
 209          {
 210   1       while(t){
 211   2         t-=1;
 212   2       }
 213   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    872    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     32      11
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
